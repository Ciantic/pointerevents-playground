import{u as e,c as t,a as n,b as o,t as i,d as r,o as s,i as a,e as l,f as c,m as d,r as u}from"./vendor.741935e8.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const n of e)if("childList"===n.type)for(const e of n.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerpolicy&&(t.referrerPolicy=e.referrerpolicy),"use-credentials"===e.crossorigin?t.credentials="include":"anonymous"===e.crossorigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();const p=i("<br>"),h=i("<span>&nbsp;</span>"),v=i('<div class="app"><h1>PointerEvents playground</h1><label><input type="checkbox"> remove touch and pen log entry on pointerleave (<!>)</label><label><input type="checkbox"> setPointerCapture on clicking down release on up (<!>)</label><label><input type="checkbox"> handle pointerevents (<!>)</label><label><input type="checkbox"> handle touchstart (<!>)</label><pre>Legacy TouchEvent touches.length = </pre><div class="test-area"><div class="text">Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Duis tincidunt erat in purus ullamcorper ultricies. Duis lacinia aliquet dolor. Maecenas velit enim, eleifend a, tempor eu, mattis in, nisl. Maecenas ut orci. Sed egestas auctor sem. Curabitur vitae pede vel nisl tristique commodo. Phasellus ut nisl. Cras massa. Suspendisse potenti. Vestibulum vitae augue.</div></div><h2>Notes</h2><p>1. Handling <code>touchstart</code> prevents iOS from triggering "text selection" when hold pressing. It\'s notable that iOS selects the text <em>below</em> the element. In this test it\'s the title "Notes" and <b>not</b> the text underneath your finger. <a target="_blank" href="https://www.youtube.com/watch?v=cYzfboD5PaE">Tested on 2021-09-18 with Safari 14.8, on iPad.</a> Notice that CSS properties <code>touch-action: none</code>, <code>user-select: none</code> or <code>-webkit-user-select: none</code> did NOT work. It also required the touchstart handling.</p><p>2. Set capture seems rather meaningless on touch screens of iOS and Android. However on desktop mouse with Google Chrome it seems necessity if you want to be able to pan a view or drag a slider naturally.</p><p>3. iOS has rather annoying bug: when using the four finger gesture to switch application, <a target="_blank" href="https://www.youtube.com/watch?v=pDGB4Hr9tKI">the pointerup or pointerleave is never triggered</a>. Tested on 2021-09-18 with Safari 14.8, on iPad.</p></div>'),f=i('<div class="pointer"></div>'),g=e=>["ID: ",d((()=>e.id)),p.cloneNode(!0),"Type: ",d((()=>e.type)),p.cloneNode(!0),d((()=>e.events.slice(-20).reverse().map((e=>(()=>{const t=h.cloneNode(!0),n=t.firstChild;return a(t,e,n),t})()))))," ",p.cloneNode(!0),"Buttons: ",d((()=>e.buttons)),p.cloneNode(!0),"Tilt: (",d((()=>e.tilt.x)),", ",d((()=>e.tilt.y)),") ",p.cloneNode(!0),"Page: (",d((()=>e.page.x.toFixed(2))),", ",d((()=>e.page.y.toFixed(2))),") ",p.cloneNode(!0),"Offset: (",d((()=>e.offset.x.toFixed(2))),", ",d((()=>e.offset.y.toFixed(2))),") ",p.cloneNode(!0),p.cloneNode(!0)],b=()=>{let i,r=function(e){const t=null!=e?e:new Map,[i,r]=o(!1),[s,a]=o(!1),[l,c]=o(!1),[d,u]=o(!0),[p,h]=o(0),v=e=>e.preventDefault(),f=e=>{h(e.touches.length)};return{touchPoints:p,handlePointerEvents:s,setHandlePointerEvents:a,removeOnLeave:d,setRemoveOnLeave:u,captureOnDown:l,setCaptureOnDown:c,handleTouchStart:i,setHandleTouchStart:r,list:()=>[...t.entries()],object:()=>Object.fromEntries(t.entries()),pointer:e=>t.get(""+e),get size(){return t.size},handle(e){var n,o;if(!(e.currentTarget instanceof HTMLElement))throw new Error("This experiment works only with elements");const i=""+e.pointerId;if(d()&&"pointerleave"===e.type&&("touch"===e.pointerType||"pen"===e.pointerType))return void t.delete(i);l()&&("pointerdown"===e.type&&e.currentTarget.setPointerCapture(e.pointerId),"pointerup"===e.type&&e.currentTarget.releasePointerCapture(e.pointerId)),s()&&e.preventDefault();let r=null!=(o=null==(n=t.get(i))?void 0:n.events)?o:[];t.set(i,{id:i,buttons:e.buttons,type:e.pointerType,tilt:{x:e.tiltX,y:e.tiltY},page:{x:e.pageX,y:e.pageY},offset:{x:e.offsetX,y:e.offsetY},events:"pointermove"!==e.type?[...r,e.type]:r})},listen(e){e.addEventListener("pointerenter",this.handle),e.addEventListener("pointerleave",this.handle),e.addEventListener("pointerdown",this.handle),e.addEventListener("pointerup",this.handle),e.addEventListener("pointermove",this.handle),e.addEventListener("touchstart",f),e.addEventListener("touchcancel",f),e.addEventListener("touchend",f),e.addEventListener("touchmove",f),n((()=>{d()&&t.clear()})),n((()=>{i()?e.addEventListener("touchstart",v):e.removeEventListener("touchstart",v)}))}}}(function(){const[n,o]=t({});return{delete(e){const t=e in n;return o(e,void 0),t},set(e,t){return o(e,t),this},get:e=>n[e],clear(){const t=e((()=>this.keys()));for(const e of t)o(e,void 0)},forEach(e){for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&e(n[t],t,this)},has:e=>e in n,get size(){return Object.keys(n).length},entries(){const e=n;return Object.entries(e)[Symbol.iterator]()},keys:()=>Object.keys(n)[Symbol.iterator](),values:()=>Object.values(n)[Symbol.iterator](),[Symbol.iterator](){return this.entries()},[Symbol.toStringTag]:"ObservableMap"}}());return s((()=>{i&&r.listen(i)})),(()=>{const e=v.cloneNode(!0),t=e.firstChild.nextSibling,n=t.firstChild,o=n.nextSibling.nextSibling;o.nextSibling;const s=t.nextSibling,d=s.firstChild,u=d.nextSibling.nextSibling;u.nextSibling;const p=s.nextSibling,h=p.firstChild,b=h.nextSibling.nextSibling;b.nextSibling;const m=p.nextSibling,y=m.firstChild,S=y.nextSibling.nextSibling;S.nextSibling;const x=m.nextSibling,w=x.firstChild,O=x.nextSibling;O.firstChild,n.$$input=e=>r.setRemoveOnLeave(e.target.checked),a(t,(()=>r.removeOnLeave()?"On":"Off"),o),d.$$input=e=>r.setCaptureOnDown(e.target.checked),a(s,(()=>r.captureOnDown()?"On":"Off"),u),h.$$input=e=>r.setHandlePointerEvents(e.target.checked),a(p,(()=>r.handlePointerEvents()?"On":"Off"),b),y.$$input=e=>r.setHandleTouchStart(e.target.checked),a(m,(()=>r.handleTouchStart()?"On":"Off"),S),a(x,(()=>r.list().map((([e,t])=>l(g,t)))),w),a(x,(()=>r.touchPoints()),null);return"function"==typeof i?i(O):i=O,a(O,(()=>r.list().map((([e,t])=>(()=>{const e=f.cloneNode(!0);return c((n=>{const o=t.offset.y+"px",i=t.offset.x+"px";return o!==n._v$5&&e.style.setProperty("top",n._v$5=o),i!==n._v$6&&e.style.setProperty("left",n._v$6=i),n}),{_v$5:void 0,_v$6:void 0}),e})()))),null),c((e=>{const t=r.removeOnLeave(),o=r.captureOnDown(),i=r.handlePointerEvents(),s=r.handleTouchStart();return t!==e._v$&&(n.checked=e._v$=t),o!==e._v$2&&(d.checked=e._v$2=o),i!==e._v$3&&(h.checked=e._v$3=i),s!==e._v$4&&(y.checked=e._v$4=s),e}),{_v$:void 0,_v$2:void 0,_v$3:void 0,_v$4:void 0}),e})()};r(["input"]),u((()=>l(b,{})),document.getElementById("root"));
